#!/usr/bin/env python3
# Copyright (C) 2016 The OpenTimestamps developers
#
# This file is part of the OpenTimestamps Client.
#
# It is subject to the license terms in the LICENSE file found in the top-level
# directory of this distribution.
#
# No part of the OpenTimestamps Client, including this file, may be copied,
# modified, propagated, or distributed except according to the terms contained
# in the LICENSE file.

import sys
sys.path.insert(1, sys.path[0] + '/python-opentimestamps/')

import argparse
import binascii
import datetime
import logging
import os
import time
import urllib.request

import bitcoin
import bitcoin.rpc

from bitcoin.core import b2x, b2lx, lx, CTxOut, CTransaction
from bitcoin.core.script import CScript, OP_RETURN

from binascii import hexlify

from opentimestamps.core.op import *
from opentimestamps.core.notary import *
from opentimestamps.core.timestamp import *
from opentimestamps.core.serialize import *
from opentimestamps.op import *
from opentimestamps.bitcoin import *

parser = argparse.ArgumentParser(description="OpenTimestamps client.")

parser.add_argument("-q", "--quiet", action="count", default=0,
                    help="Be more quiet.")
parser.add_argument("-v", "--verbose", action="count", default=0,
                    help="Be more verbose. Both -v and -q may be used multiple times.")

parser.add_argument('--calendar-uri', metavar='URI', dest='calendar_uri', action='store',
                    default='https://btc.calendar.opentimestamps.org',
                    help='URI of remote calendar.')

btc_net_group  = parser.add_mutually_exclusive_group()
btc_net_group.add_argument('--btc-testnet', dest='btc_net', action='store_const',
                    const='testnet', default='mainnet',
                    help='Use Bitcoin testnet rather than mainnet')
btc_net_group.add_argument('--btc-regtest', dest='btc_net', action='store_const',
                    const='regtest',
                    help='Use Bitcoin regtest rather than mainnet')

subparsers = parser.add_subparsers(title='Subcommands',
                                   description='All operations are done through subcommands:')

# ----- stamp -----
parser_stamp = subparsers.add_parser('stamp', aliases=['s'],
                                     help='Timestamp files')
parser_stamp.add_argument('--no-nonce', dest='use_nonce', action='store_false', default=True,
                          help='Do not use a nonce in the hash calculation. WARNING: may cause privacy loss!')


stamp_type_group = parser_stamp.add_mutually_exclusive_group()
stamp_type_group.add_argument('-c','--calendar', dest='method', action='store_const',
                          const='calendar', default='calendar',
                          help='Create timestamp with the aid of a remote calendar. (default)')
stamp_type_group.add_argument('-w','--btc-wallet', dest='method', action='store_const',
                          const='btc-wallet',
                          help='Create timestamp locally with the local Bitcoin wallet.')

parser_stamp.add_argument('files', metavar='FILE', type=argparse.FileType('rb'),
                          nargs='+',
                          help='Filename')

# ----- upgrade -----
parser_upgrade = subparsers.add_parser('upgrade', aliases=['u'],
                                        help='Upgrade existing timestamps to better proof')
parser_upgrade.add_argument('files', metavar='FILE', type=argparse.FileType('r'),
                            nargs='+',
                            help='Filename')

# ----- verify -----
parser_verify = subparsers.add_parser('verify', aliases=['v'],
                                      help="Verify a timestamp")

verify_target_group = parser_verify.add_mutually_exclusive_group()
verify_target_group.add_argument('-f', metavar='FILE', dest='target_fd', type=argparse.FileType('rb'),
                                 default=None,
                                 help='Specify target file explicitly')
verify_target_group.add_argument('-d', metavar='DIGEST', dest='hex_digest', type=str,
                                 default=None,
                                 help='Verify a (hex-encoded) digest rather than a file')

parser_verify.add_argument('timestamp_fd', metavar='TIMESTAMP', type=argparse.FileType('rb'),
                           help='Timestamp filename')

# ----- info -----
parser_info = subparsers.add_parser('info', aliases=['u'],
                                        help='Show information on a timestamp')
parser_info.add_argument('file', metavar='FILE', type=argparse.FileType('rb'),
                            help='Filename')

def setup_bitcoin(args):
    """Setup Bitcoin-related functionality

    Sets mainnet/testnet and returns a RPC proxy.
    """
    if args.btc_net == 'testnet':
       bitcoin.SelectParams('testnet')
    elif args.btc_net == 'regtest':
       bitcoin.SelectParams('regtest')

    return bitcoin.rpc.Proxy()

def stamp_command(args):
    # Create initial commitment ops for all files
    file_op_paths = []
    for fd in args.files:
        # FIXME: handle file IO errors
        op = OpSHA256.from_fd(fd)
        file_op_paths.append(op)

    # Remember that the files - and their timestamps - might get separated
    # later, so if we didn't use a nonce for every file, the timestamp
    # would leak information on the digests of adjacent files.
    merkle_roots = [cat_sha256(file_op_path, os.urandom(16)) if args.use_nonce else file_op_path for file_op_path in file_op_paths]

    tip_op = make_merkle_tree(merkle_roots)

    time_attestation = None
    if args.method == 'calendar':
        req = urllib.request.Request(args.calendar_uri + '/commitment',data=bytes(tip_op))
        with urllib.request.urlopen(req) as resp:
            assert resp.status == 200

            ctx = StreamDeserializationContext(resp)
            Op.deserialize_extend(ctx, tip_op)

            time_attestation = TimeAttestation.deserialize(ctx)

    elif args.method == 'btc-wallet':
        proxy = setup_bitcoin(args)

        unfunded_tx = CTransaction([],[CTxOut(0, CScript([OP_RETURN, bytes(tip_op)]))])
        r = proxy.fundrawtransaction(unfunded_tx) # FIXME: handle errors
        funded_tx = r['tx']

        r = proxy.signrawtransaction(funded_tx)
        assert r['complete']
        signed_tx = r['tx']

        txid = proxy.sendrawtransaction(signed_tx)
        logging.info('Sent timestamp tx')

        blockhash = None
        while blockhash is None:
            logging.info('Waiting for timestamp tx %s to confirm...' % b2lx(txid))
            time.sleep(1)

            r = proxy.gettransaction(txid)

            if 'blockhash' in r:
                # FIXME: this will break when python-bitcoinlib adds RPC
                # support for gettransaction, due to formatting differences
                blockhash = lx(r['blockhash'])

        logging.info('Confirmed by block %s' % b2lx(blockhash))

        # We have a block hash! We can now generate the attestation from the block.
        time_attestation = make_bitcoin_attestation_from_blockhash(tip_op, blockhash, proxy)

    else:
        assert False # Shouldn't happen

    for (in_file, file_op_path) in zip(args.files, file_op_paths):
        timestamp_file_path = in_file.name + '.ots'
        with open(timestamp_file_path, 'xb') as timestamp_fd:
            timestamp = Timestamp(file_op_path, time_attestation)
            detached_timestamp = DetachedTimestampFile(timestamp)

            #import pdb; pdb.set_trace()

            ctx = StreamSerializationContext(timestamp_fd)
            detached_timestamp.serialize(ctx)

parser_stamp.set_defaults(cmd_func=stamp_command)


def upgrade_command(args):
    pass

parser_upgrade.set_defaults(cmd_func=upgrade_command)


def verify_command(args):
    ctx = StreamDeserializationContext(args.timestamp_fd)
    detached_timestamp = DetachedTimestampFile.deserialize(ctx)

    if args.hex_digest is not None:
        try:
            digest = binascii.unhexlify(args.hex_digest.encode('utf8'))
        except ValueError:
            parser.error('Digest must be hexidecimal')

        if not digest == detached_timestamp.file_digest:
            logging.error("Digest provided does not match digest in timestamp, %s (%s)" %
                          (b2x(detached_timestamp.file_digest), detached_timestamp.file_hash_op_class.TAG_NAME))
            sys.exit(1)

    else:
        if args.target_fd is None:
            # Target not specified, so assume it's the same name as the
            # timestamp file minus the .ots extension.
            if not args.timestamp_fd.name.endswith('.ots'):
                parser.error('Timestamp filename does not end in .ots')

            target_filename = args.timestamp_fd.name[:-4]
            logging.info("Assuming target filename is %r" % target_filename)

            args.target_fd = open(target_filename, 'rb')

        logging.debug("Hashing file, algorithm %s" % detached_timestamp.file_hash_op_class.TAG_NAME)
        actual_digest_op = detached_timestamp.file_hash_op_class.from_fd(args.target_fd)
        logging.debug("Got digest %s" % b2x(actual_digest_op.result))

        if actual_digest_op.result != detached_timestamp.file_digest:
            logging.debug("Expected digest %s" % b2x(detached_timestamp.file_digest))
            logging.error("File does not match original!")
            sys.exit(1)


    # File/digest is same as original. Next step is to check that the timestamp
    # attestation is still valid.

    attested_time = None

    attestation = detached_timestamp.timestamp.attestation
    if attestation.__class__ == PendingAttestation:
        raise NotImplementedError

    elif attestation.__class__ == BitcoinBlockHeaderAttestation:
        proxy = setup_bitcoin(args)

        try:
            blockhash = proxy.getblockhash(attestation.height)
        except IndexError:
            logging.error("Can't find Bitcoin block! Height %d" % attestation.height)
            sys.exit(1)

        block_header = proxy.getblockheader(blockhash)

        logging.debug("Attestation block hash: %s" % b2lx(blockhash))

        final_commitment = detached_timestamp.timestamp.path.final_commitment()

        try:
            attested_time = attestation.verify_against_blockheader(final_commitment, block_header)
        except VerificationError as err:
            logging.error("Bitcoin verification failed: %s" % str(err))
            sys.exit(1)


        logging.debug("Attested time: %d", attested_time)
        logging.info("Success! Bitcoin blockchain attests data existed prior to %s" % \
                        datetime.datetime.fromtimestamp(attested_time).isoformat(' '))


parser_verify.set_defaults(cmd_func=verify_command)

def info_command(args):
    ctx = StreamDeserializationContext(args.file)
    detached_timestamp = DetachedTimestampFile.deserialize(ctx)

    print("File %s hash: %s" % (detached_timestamp.timestamp.path.HASHLIB_NAME, hexlify(detached_timestamp.timestamp.path.result).decode('utf8')))

    print("Path ops:")

    op = detached_timestamp.timestamp.path
    while op is not None:
        print('    ' + str(op))

        if args.verbosity > 0:
            print('-> %s' % hexlify(op.result).decode('utf8'))

        op = op.next_op

    print(detached_timestamp.timestamp.attestation)


parser_info.set_defaults(cmd_func=info_command)

args = parser.parse_args()
args.parser = parser


args.verbosity = args.verbose - args.quiet

if args.verbosity == 0:
    logging.root.setLevel(logging.INFO)
elif args.verbosity > 0:
    logging.root.setLevel(logging.DEBUG)
elif args.verbosity == -1:
    logging.root.setLevel(logging.WARNING)
elif args.verbosity < -1:
    logging.root.setLevel(logging.ERROR)

if not hasattr(args, 'cmd_func'):
    parser.error('No command specified')

args.cmd_func(args)

# vim:syntax=python filetype=python
